#!/usr/bin/env python
# -*- encoding: utf8 -*-

'''
Change gen_command if you don't use vim.
Change input mappings if you are not used to the default inputs.
'''

import re
import subprocess
import sys
import optparse
import os
import platform


__author__ = 'fcamel'


#------------------------------------------------------------------------------
# Configuration
#------------------------------------------------------------------------------
def gen_vim_command(filename, line, pattern):
    return 'vi %s -c/%s +%s' % (filename, pattern, line)

gen_command = gen_vim_command

# Input mappings
A_KEEP_STATEMENT  = ';'
A_CLEAN_STATEMENT = '!;'
A_FOLD            = '.'
A_RESTART         = '~'

#------------------------------------------------------------------------------
# Helper functions
#------------------------------------------------------------------------------
class Match(object):
    def __init__(self, tokens, pattern):
        self.filename, self.line_num, self.text = tokens
        self.line_num = int(self.line_num)
        self.column = self.text.index(pattern)

    @staticmethod
    def create(line, pattern):
        tokens = line.split(':', 2)
        if len(tokens) != 3:
            return None
        return Match(tokens, pattern)

    def __unicode__(self):
        tokens = [self.filename, self.line_num, self.column, self.text]
        return u':'.join(map(unicode, tokens))

    def __str__(self):
        return str(unicode(self))

def get_gid_cmd():
    gid = 'gid'
    if platform.system() == 'Darwin':
        gid = 'gid32'
    return gid

def check_install():
    for cmd in ['mkid', get_gid_cmd()]:
        ret = os.system('which %s > /dev/null' % cmd)
        if ret != 0:
            msg = (
                "The program '%s' is currently not installed.  "
                "You can install it by typing:\n" % cmd
            )
            if platform.system() == 'Darwin':
                msg += "sudo port install idutils"
            else:
                msg += "sudo apt-get install id-utils"
            print msg
            sys.exit(1)

def _gid(pattern):
    cmd = [get_gid_cmd(), pattern]
    process = subprocess.Popen(cmd,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    return process.stdout.read().split('\n')

def get_list(patterns=None):
    if patterns is None:
        patterns = get_list.original_patterns
    first_pattern = patterns[0]

    lines = _gid(first_pattern)
    matches = [Match.create(line, first_pattern) for line in lines]
    matches = [m for m in matches if m]

    for pattern in patterns[1:]:
        matches = _filter_pattern(matches, pattern)

    return matches

get_list.original_patterns = []

def show_list(matches, patterns, last_n, fold):
    def yellow(text):
        return '\033[1;33m%s\033[0m' % text

    def yellow_background(text):
        return '\033[30;43m%s\033[0m' % text

    def green(text):
        return '\033[1;32m%s\033[0m' % text

    def red(text):
        return '\033[1;31m%s\033[0m' % text

    def black(text):
        return '\033[1;30m%s\033[0m' % text

    os.system('clear')
    last_filename = ''
    for i, m in enumerate(matches):
        if fold and m.filename == last_filename:
            continue

        last_filename = m.filename
        i += 1
        if i == last_n:
            print black('(%s) %s:%s:%s' % (i, m.line_num, m.filename, m.text))
        else:
            for pattern in patterns:
                code = m.text.replace(pattern, yellow_background(pattern))
            print '(%s) %s:%s:%s' % (red(i), yellow(m.line_num), green(m.filename), code)

def _diff_list(kept, removed):
    return [e for e in kept if e not in removed]

def _filter_statement(all_, exclude):
    matches = [m for m in all_ if re.search(';\s*$', m.text)]
    if not exclude:
        return matches
    return _diff_list(all_, matches)

def _filter_filename(all_, pattern, exclude):
    matched = [m for m in all_ if re.search(pattern, m.filename)]
    if not exclude:
        return matched
    return _diff_list(all_, matched)

def _filter_pattern(matches, pattern):
    negative_symbol = '~'

    new_matches = []
    new_pattern = pattern[1:] if pattern.startswith(negative_symbol) else pattern
    for m in matches:
        matched = not not re.search('\\b%s\\b' % new_pattern, m.text)
        if pattern.startswith(negative_symbol):
            matched = not matched
        if matched:
            new_matches.append(m)

    return new_matches

def filter_until_select(matches, patterns, last_n):
    '''
    Return:
        >0: selected number.
         0: normal exit.
        <0: error.
    '''
    matches = matches[:]  # Make a clone.

    # Enter interactive mode.
    if not hasattr(filter_until_select, 'fold'):
        filter_until_select.fold = False
    while True:
        if not matches:
            print 'No file matched.'
            return 0, matches, patterns

        show_list(matches, patterns, last_n, filter_until_select.fold)
        msg = (
            '\nSelect an action:'
            '\n* Input number to select a file.'
            '\n* Type "%s" / "%s" to keep / remove statements.'
            '\n* Type "%s" to switch between all matches and fold matches.'
            '\n* Type STRING (regex) to filter filename. !STRING means exclude the matched filename: '
            '\n* Type %s[PATTERN1 PATTERN2 ~PATTERN3 ...] to start over. '
            '\n  Type only "%s" to use the patterns from the command line.'
            '\n* Type ENTER to exit.'
            '\n'
            '\n>> ' % (A_KEEP_STATEMENT, A_CLEAN_STATEMENT, A_FOLD, A_RESTART, A_RESTART)
        )
        response = raw_input(msg).strip()
        if not response:
            return 0, matches, patterns

        if re.match('\d+', response):
            break

        # Clean/Keep statements
        if response in [A_CLEAN_STATEMENT, A_KEEP_STATEMENT]:
            matches = _filter_statement(matches, response == A_CLEAN_STATEMENT)
            continue

        if response == A_FOLD:
            filter_until_select.fold = not filter_until_select.fold
            continue

        if response[0] == A_RESTART:
            if len(response) == 1:
                matches = get_list()
            else:
                patterns = response[1:].split()
                matches = get_list(patterns)
            continue

        # Clean/Keep based on filename
        if response[0] == '!':
            exclude = True
            response = response[1:]
        else:
            exclude = False
        matches = _filter_filename(matches, response, exclude)

    # Parse the selected number
    try:
        n = int(response)
    except ValueError, e:
        print 'Invalid input.'
        return -1, matches, patterns

    if n < 1 or n > len(matches):
        print 'Invalid input.'
        return -1, matches, patterns

    return n, matches, patterns

def _filter_filename(all_, pattern, exclude):
    matched = [m for m in all_ if re.search(pattern, m.filename)]
    if not exclude:
        return matched
    return _diff_list(all_, matched)

def _keep_definition(all_, pattern):
    new_pattern = ':%s(' % pattern
    return [m for m in all_ if new_pattern in m.text]

def find_declaration_or_definition(pattern):
    if pattern.startswith('m_') or pattern.startswith('s_'):
        # For non-static member fields or static member fields,
        # find symobls in header files.
        matches = get_list([pattern])
        return _filter_filename(matches, '\.h$', False)

    # Find declaration if possible.
    result = []
    matches = get_list([pattern, 'class'])
    matches = _filter_statement(matches, True)
    result += matches
    result += get_list([pattern, 'typedef'])
    result += get_list([pattern, 'define'])
    # Find definition if possible.
    matches = _keep_definition(get_list([pattern]), pattern)
    result += matches
    return result

#------------------------------------------------------------------------------
# main
#------------------------------------------------------------------------------
def main():
    '''\
    %prog [options] <pattern> [<pattern> ...]

    Grep pattern in source codes using id-utils.
    Before starting, type 'mkid' in your source root first.

    Example of usages:
        $ gj MyClient         # find any snippet which contains MyClient
        $ gj MyClient class   # find the definition.
    '''
    check_install()

    parser = optparse.OptionParser(usage=main.__doc__)
    parser.add_option('-d', '--declaration', dest='declaration', action='store_true', default=False,
                      help='Find possible declarations.')
    options, args = parser.parse_args()

    if len(args) < 1:
        parser.print_help()
        sys.exit(1)

    if not os.path.exists('ID'):
        print 'Database file "ID" is not found. Have you run "mkid"?'
        return 2

    patterns = args

    # Find the initial matched set.
    get_list.original_patterns = patterns
    if options.declaration:
        matches = find_declaration_or_definition(patterns[0])
    else:
        matches = get_list()

    # Filter the rest or view the selected file.
    n = 0
    while True:
        n, matches, patterns = filter_until_select(matches, patterns, n)
        if n <= 0:
            if n < 0:
                return 1
            return 0

        # Edit the chosen one.
        m = matches[n - 1]

        ret = os.system(gen_command(m.filename, m.line_num, patterns[0]))
        if ret != 0:
            return 2

    return 0


if __name__ == '__main__':
    sys.exit(main())
