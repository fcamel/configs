#!/usr/bin/env python
# -*- encoding: utf8 -*-

'''
Change gen_command if you don't use vim.
Change input mappings if you are not used to the default inputs.
'''

import curses
import optparse
import os
import re
import subprocess
import sys


__author__ = 'fcamel, Owen Chu'


#------------------------------------------------------------------------------
# Supplemental defines for curses
#------------------------------------------------------------------------------
KEY_CTRL_D  = 4
KEY_CTRL_U  = 21

#------------------------------------------------------------------------------
# Configuration
#------------------------------------------------------------------------------
def gen_vim_command(filename, line, pattern):
    return 'vi %s -c/%s +%s' % (filename, pattern, line)

gen_command = gen_vim_command

# Input mappings
A_SCROLL_DOWN        = { KEY_CTRL_D: '^D' }
A_SCROLL_UP          = { KEY_CTRL_U: '^U' }
A_SELECT             = { ord('s'): '"s"' }
A_STATEMENT          = { ord(';'): '";"' }
A_FOLD               = { ord('.'): '"."' }
A_FILTER_FILENAMES   = { ord('f'): '"f"' }
A_EXCLUDE_FILENAMES  = { ord('F'): '"F"' }
A_RESTART            = { ord('`'): '"`"' }
A_RESTART_NEW_SEARCH = { ord('r'): '"r"' }
A_EXIT               = { ord('q'): '"q"' }

#------------------------------------------------------------------------------
# Help messages
#------------------------------------------------------------------------------
def key_mapping_repr(*key_mappings):
    values = []
    for mapping in key_mappings:
        values.extend(mapping.values())
    return ' / '.join(values)

HELP_MESSAGES = (
    'Select an action:',
    '  %s to scroll search results.' % key_mapping_repr(A_SCROLL_DOWN, A_SCROLL_UP),
    '  %s to select and edit a file.' % key_mapping_repr(A_SELECT),
    '  %s to show / hide statements.' % key_mapping_repr(A_STATEMENT),
    '  %s to switch between all matches and fold matches.' % key_mapping_repr(A_FOLD),
    '  %s to filter filenames.' % key_mapping_repr(A_FILTER_FILENAMES),
    '  %s to exclude filenames.' % key_mapping_repr(A_EXCLUDE_FILENAMES),
    '  %s to restart search with patterns from command line.' % key_mapping_repr(A_RESTART),
    '  %s to restart search with new patterns.' % key_mapping_repr(A_RESTART_NEW_SEARCH),
    '  %s to exit.' % key_mapping_repr(A_EXIT)
)

#------------------------------------------------------------------------------
# Helper functions for id-utils
#------------------------------------------------------------------------------
def check_install():
    for cmd in ['mkid', 'gid']:
        ret = os.system('which %s > /dev/null' % cmd)
        if ret != 0:
            msg = (
                "The program '%s' is currently not installed.  "
                "You can install it by typing:\n"
                "sudo apt-get install id-utils" % cmd
            )
            print msg
            sys.exit(1)

def gid(pattern):
    cmd = ['gid', pattern]
    process = subprocess.Popen(cmd,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    return process.stdout.read().split('\n')

def get_list(patterns=None):
    if patterns is None:
        patterns = get_list.original_patterns
    first_pattern = patterns[0]

    lines = gid(first_pattern)
    tokens_list = [line.split(':', 2) for line in lines]
    tokens_list = [ts for ts in tokens_list if len(ts) == 3]

    for pattern in patterns[1:]:
        tokens_list = filter_pattern(tokens_list, pattern)

    return tokens_list

get_list.original_patterns = []

#------------------------------------------------------------------------------
# Helper functions for curses
#------------------------------------------------------------------------------
def init_color_pairs():
    curses.init_pair(1, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_YELLOW)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_BLUE, curses.COLOR_BLACK)

# TODO: Make the layout configurable?
def split_screen(screen, minimalist):
    '''Split the screen into four views (status, list, help, and prompt)

    Arguments:
    screen -- A curses window

    Returns:
    Four curses windows with proper blank lines in between
        
    '''
    screen_height, screen_width = screen.getmaxyx()

    # Minimalist layout:
    #   Status view
    #   ................. one blank line
    #   List view
    #   ................. one blank line
    #   Prompt view
    #   ................. one blank line
    #
    # Normal layout:
    #   Status view
    #   ................. one blank line
    #   List view
    #   ................. one blank line
    #   Help view
    #   ................. one blank line
    #   Prompt view
    #   ................. one blank line
    status_height = 1
    prompt_height = 1

    if minimalist:
        list_height = screen_height - (status_height + prompt_height + 3)
    else:
        help_height = len(HELP_MESSAGES)
        list_height = screen_height - (status_height + help_height +
                                       prompt_height + 4)

    if list_height <= 0:
        return None, None, None, None

    pos_y = 0

    status_view = screen.subwin(status_height, screen_width, pos_y, 0)
    pos_y += (status_height + 1)

    list_view = screen.subwin(list_height, screen_width, pos_y, 0)
    pos_y += (list_height + 1)

    if minimalist:
        help_view = None
    else:
        help_view = screen.subwin(help_height, screen_width, pos_y, 0)
        pos_y += (help_height + 1)

    prompt_view = screen.subwin(prompt_height, screen_width, pos_y, 0)

    return status_view, list_view, help_view, prompt_view

def show_status(status_view, display_type, fold):
    status_view.erase()
    status_view.move(0, 0)

    status_view.attron(curses.A_REVERSE)
    if display_type == DisplayType.ALL:
        status_view.addstr('Statements + Non-statements')
    elif display_type == DisplayType.STATEMENTS:
        status_view.addstr('Statements only')
    elif display_type == DisplayType.EXCLUDE_STATEMENTS:
        status_view.addstr('Non-statements only')
    else:
        assert 0
    status_view.attroff(curses.A_REVERSE)

    status_view.addch(' ')

    if fold:
        status_view.addstr('Folded', curses.A_REVERSE)

    status_view.refresh()

def show_list(list_view, display_list, start_index, patterns, selected_item):
    # Color aliases
    yellow = curses.color_pair(1) | curses.A_BOLD
    yellow_background = curses.color_pair(2)
    green = curses.color_pair(3) | curses.A_BOLD
    red = curses.color_pair(4) | curses.A_BOLD
    blue = curses.color_pair(5)

    list_view.erase()
    list_view_height, list_view_width = list_view.getmaxyx()

    # These are the items that are seeable on screen
    seeable_list = display_list[start_index : start_index + list_view_height]

    # Create a pad to hold seeable items because the potential output could be
    # wider than list_view's width
    pad = curses.newpad(list_view_height, 512) # Maybe 512 is wide enough

    pos_y = 0

    for item_index, item in enumerate(seeable_list, start_index + 1):
        filename, line_number, code = item
        pad.move(pos_y, 0)

        if item == selected_item:
            pad.addstr(
                '(%d) %s:%s: %s' % (item_index, line_number, filename, code),
                blue)
        else:
            pad.addstr('(')
            pad.addstr(str(item_index), red)
            pad.addstr(') ')
            pad.addstr(line_number, yellow)
            pad.addstr(':')
            pad.addstr(filename, green)
            pad.addstr(': ')

            highlight_pos = []
            for pattern in patterns:
                highlight_pos.extend(
                    [m.span() for m in re.finditer(pattern, code)])
            highlight_pos.sort()

            i = 0
            for start, end in highlight_pos:
                if i < start:
                    # Output code up to the highlighted part
                    pad.addstr(code[i:start])
                    pad.addstr(code[start:end], yellow_background)
                elif i == start:
                    # Output highlighted part
                    pad.addstr(code[start:end], yellow_background)
                else:
                    # Skip overlapped entries
                    continue
                i = end

            # Output the rest of the code
            pad.addstr(code[i:])

        pos_y += 1

    # Display pad's contents on list_view
    y, x = list_view.getbegyx()
    pad.refresh(0, 0, y, x, y + list_view_height - 1, x + list_view_width - 1)

def show_help(help_view):
    help_view.erase()
    for i, msg in enumerate(HELP_MESSAGES):
        help_view.addstr(i, 0, msg)
    help_view.refresh()

def show_prompt(prompt_view, prompt=''):
    prompt_view.erase()
    prompt_view.addstr(0, 0, '%s> ' % prompt)
    prompt_view.refresh()

def get_input_from_user(prompt_view, prompt):
    show_prompt(prompt_view, prompt)
    curses.echo()
    s = prompt_view.getstr()
    curses.noecho()
    return s.strip()

#------------------------------------------------------------------------------
# Helper functions for filtering
#------------------------------------------------------------------------------
def enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    return type('Enum', (), enums)

DisplayType = enum('ALL', 'STATEMENTS', 'EXCLUDE_STATEMENTS')

def switch_display_type(display_type):
    # Should have a better way to do this?
    if display_type == DisplayType.ALL:
        return DisplayType.STATEMENTS
    elif display_type == DisplayType.STATEMENTS:
        return DisplayType.EXCLUDE_STATEMENTS
    elif display_type == DisplayType.EXCLUDE_STATEMENTS:
        return DisplayType.ALL
    else:
        assert 0

def diff_list(kept, removed):
    return [e for e in kept if e not in removed]

def filter_statement(tokens_list, exclude):
    matched = [tokens for tokens in tokens_list if re.search(';\s*$', tokens[2])]
    if not exclude:
        return matched
    return diff_list(tokens_list, matched)

def filter_filename(tokens_list, pattern, exclude):
    matched = [tokens for tokens in tokens_list if re.search(pattern, tokens[0])]
    if not exclude:
        return matched
    return diff_list(tokens_list, matched)

def filter_pattern(tokens_list, pattern):
    return [tokens for tokens in tokens_list if re.search('\\b%s\\b' % pattern, tokens[2])]

def filter_list(tokens_list, display_type, fold):
    if display_type == DisplayType.ALL:
        filtered_list = tokens_list[:]
    elif display_type == DisplayType.STATEMENTS:
        filtered_list = filter_statement(tokens_list, False)
    elif display_type == DisplayType.EXCLUDE_STATEMENTS:
        filtered_list = filter_statement(tokens_list, True)
    else:
        assert 0
        
    if fold:
        temp_list = [] 
        last_filename = ''
        for item in filtered_list:
            filename = item[0]
            if filename == last_filename:
                continue
            last_filename = filename
            temp_list.append(item)
        filtered_list = temp_list

    return filtered_list

def filter_until_select(screen, tokens_list, patterns,
                        selected_item, minimalist):
    '''
    Returns:
    selected_item -- The selected item
    tokens_list
    patterns
    '''
    def reset_display_type():
        filter_until_select.display_type = DisplayType.ALL
    def reset_fold():
        filter_until_select.fold = False

    if not hasattr(filter_until_select, 'display_type'):
        reset_display_type()
    if not hasattr(filter_until_select, 'fold'):
        reset_fold()

    tokens_list = tokens_list[:]  # Make a clone.

    status_view, list_view, help_view, prompt_view = split_screen(screen,
                                                                  minimalist)
    if not minimalist:
        show_help(help_view)

    start_index = 0

    # Enter interactive mode.
    while True:
        display_list = filter_list(tokens_list,
                                   filter_until_select.display_type,
                                   filter_until_select.fold)
        if not display_list:
            return None, tokens_list, patterns

        show_list(list_view, display_list, start_index, patterns, selected_item)
        show_status(status_view,
                    filter_until_select.display_type,
                    filter_until_select.fold)
        show_prompt(prompt_view)

        cmd = prompt_view.getch()

        if cmd in A_SCROLL_DOWN:
            # Scroll half page down if possible
            list_view_height, _ = list_view.getmaxyx()
            if (len(display_list) - start_index) > list_view_height:
                start_index += (list_view_height / 2)
        elif cmd in A_SCROLL_UP:
            # Scroll half page up if possible
            list_view_height, _ = list_view.getmaxyx()
            start_index -= (list_view_height / 2)
            if start_index < 0:
                start_index = 0
        elif cmd in A_SELECT:
            num = get_input_from_user(prompt_view, 'Select a file to edit')
            try:
                n = int(num)
                return display_list[n - 1], tokens_list, patterns
            except:
                # Ignore invalid input
                pass
        elif cmd in A_STATEMENT:
            filter_until_select.display_type = \
                switch_display_type(filter_until_select.display_type)
            start_index = 0
        elif cmd in A_FOLD:
            filter_until_select.fold = not filter_until_select.fold
            start_index = 0
        elif cmd in A_FILTER_FILENAMES:
            files = get_input_from_user(prompt_view, 'Filter filenames')
            if files:
                tokens_list = filter_filename(tokens_list, files, False)
                start_index = 0
        elif cmd in A_EXCLUDE_FILENAMES:
            files = get_input_from_user(prompt_view, 'Exclude filenames')
            if files:
                tokens_list = filter_filename(tokens_list, files, True)
                start_index = 0
        elif cmd in A_RESTART:
            tokens_list = get_list()
            reset_display_type()
            reset_fold()
            start_index = 0
        elif cmd in A_RESTART_NEW_SEARCH:
            patterns = get_input_from_user(
                            prompt_view, 'Restart search').split()
            if patterns:
                tokens_list = get_list(patterns)
                reset_display_type()
                reset_fold()
                start_index = 0
        elif cmd in A_EXIT:
            return None, None, None 
        else:
            # Ignore undefined commands
            pass

    assert 0, 'Should never reach here'

#------------------------------------------------------------------------------
# main
#------------------------------------------------------------------------------
def curses_main(stdscr, tokens_list, patterns, minimalist):
    init_color_pairs()

    # Filter the rest or view the selected file.
    selected_item = None
    while True:
        selected_item, tokens_list, patterns = \
                filter_until_select(stdscr, tokens_list, patterns,
                                    selected_item, minimalist)

        if not selected_item:
            break

        # Edit the chosen one.
        filename, line, _ = selected_item

        ret = os.system(gen_command(filename, line, patterns[0]))

        if ret != 0:
            return 1

        stdscr.erase()
        stdscr.refresh()

    return 0

def main():
    '''\
    %prog [options] <pattern> [<pattern> ...]

    Grep pattern in source codes using id-utils.
    Before starting, type 'mkid' in your source root first.

    Example of usages:
        $ gj MyClient         # find any snippet which contains MyClient
        $ gj MyClient class   # find the definition.
    '''
    check_install()

    parser = optparse.OptionParser(usage=main.__doc__)
    parser.add_option('-m', '--minimalist', help="minimalist mode",
                      action="store_true", dest="minimalist", default=False)
    options, args = parser.parse_args()

    if len(args) < 1:
        parser.print_help()
        sys.exit(1)

    if not os.path.exists('ID'):
        print 'Database file "ID" is not found. Have you run "mkid"?'
        return 2

    patterns = args

    # Find the initial matched set.
    get_list.original_patterns = patterns
    tokens_list = get_list()

    if not tokens_list:
        print 'No file matched.'
        return 3

    return curses.wrapper(curses_main, tokens_list, patterns,
                          options.minimalist)


if __name__ == '__main__':
    sys.exit(main())
